# <center>CS216 Algorithm Design - Project1-Zip Compressor</center>

[TOC]

####  name: 廖铭骞

#### SID: 12012919

## Part1 Introduction

Zip 是一种数据文件压缩的格式，由 Phil Katz 发明，zip 压缩是通过重新对指定文件内部的数据进行重新编码之后实现压缩，以此可以减少大文件的传输时的带宽需求，也可以缩短磁盘访问I/O的时间，在得到一个zip 文件之后，可以通过一定的规则进行解压缩，得到压缩前的文件。

本次 project，我使用了 C++ 对zip 进行了实现， 工作主要分为三阶段：第一个阶段先是通过阅读zip 格式的文档了解了zip各个字段编码方式及其作用，然后通过 C++ 的文件I/O操作对相应字段进行正确的填充；第二个阶段是实现 zip 当中的压缩算法，即 deflate 算法，deflate 算法的实现结合了 LZ77 的编码方法以及哈夫曼压缩的编码思想，在使用 LZ77 编码重新编码文件之后，再使用哈夫曼编码进行字节流的再编码，进而得到最终的压缩文件流，填充到相应的字段当中；第三个阶段则是对实现了zip压缩之后的性能进行测试与改进，探究并分析了文件压缩率以及文件压缩时间与文件大小的关系，以及通过改进优化代码提升压缩的性能以及效率的尝试。

## Part2 Analysis

### Zip 格式

#### 字段解析

对于整体的 zip 文件格式，可以用下列的字段结构进行阐释

```wiki
	  [local file header 1]
      [encryption header 1]
      [file data 1]
      [data descriptor 1]
      . 
      .
      .
      [local file header n]
      [encryption header n]
      [file data n]
      [data descriptor n]
      [archive decryption header] 
      [archive extra data record] 
      [central directory header 1]
      .
      .
      .
      [central directory header n]
      [zip64 end of central directory record]
      [zip64 end of central directory locator] 
      [end of central directory record]
```

从上表可以看出，`ZIP` 文件主要由三部分构成，分别为压缩源文件数据区、核心目录以及核心目录的结束。

一开始可以通过查看一个简单的 zip 文件的内部编码以及结合zip 编码的文档了解到各个字段表示的含义，下图是通过压缩一个只包含了 `Hello ` 的文本文件得到的zip格式文件：

![image-20220414161821437](C:\Users\86181\AppData\Roaming\Typora\typora-user-images\image-20220414161821437.png)

在ZIP当中采用的是低字节优先的编码方式，即在一个字节里面低位优先，所以实际的字节顺序会和以上显示的顺序相反。

##### 本地文件头（Local file header）

位于一开始的字段是本地文件头字段，对于每一个需要压缩的文件，zip 都会为它们分别产生一个本地文件头字段。

以该zip文件为例，下表展示了压缩源文件数据区的文件头部分的内容以及含义

| 字段大小 |  字段内容  |                字段含义                |
| :------: | :--------: | :------------------------------------: |
|  4 字节  | 0x04034b50 |       标识了本地文件头字段的开始       |
|  2 字节  |   0x0014   |    规定了解压该文件所需要的最低版本    |
|  2字节   |   0x0000   |              通用位的标记              |
|  2字节   |   0x0008   | 压缩方法（0x0008表示使用deflate 压缩） |
|  2字节   |   0x7b38   |          压缩文件最后修改时间          |
|  2字节   |   0x548b   |          压缩文件最后修改日期          |
|  4字节   | 0xf7d18982 |            文件的CRC32标识             |
|  4字节   | 0x00000007 |             文件压缩后大小             |
|  4字节   | 0x00000005 |             文件压缩前大小             |
|  2字节   |   0x0009   |               文件名长度               |
|  2字节   |   0x0000   |              扩展区的长度              |

在文件头部分之后对应字段是文件的名字，由于该zip文件解析的文件名字是`hello.txt`，所以对应字段对应的是其ASCII码值。

文件名字段之后是压缩后的文件内容，在文件内容开始之前，还有3比特的加密头部（encryption header），由于该文件的压缩采用了deflate 的压缩方式，且由于文件比较小，总共只有一个块，所以前三个比特填充为 `0b101`，之后是文件内容压缩之后的字节流。

而对于数据描述符记录（data descriptor），当使用中央目录加密方法时，数据描述符记录不是必需的，但可以使用。如果存在，则通用位字段的第 3 位设置为1来指示其存在，且数据描述符记录的字段中的值必须设置为二进制零。

对于存档解密头字段（archive decryption header)以及存档解密附加字段（Archive Extra Data Record），两个记录的存在是为了支持文档规范当中的中央目录加密功能。 当中央目录结构数据被加密时，解密头以及解密附加数据段必须在加密数据段之前，提供解密相关数据信息。

##### 核心目录（Central directory）

之后是 zip 格式的第二部分——核心目录，字段 `0x02014b50`标识着核心目录的开头，下表展示了核心目录部分的内容以及含义

| 字段大小 |  字段内容  |                字段含义                |
| :------: | :--------: | :------------------------------------: |
|  4字节   | 0x02014b50 |            核心目录起始标识            |
|  2字节   |   0x000a   |         压缩使用的PKWare 版本          |
|  2字节   |   0x000a   |        解压缩需要的PKWare 版本         |
|  2字节   |   0x0000   |               通用位标记               |
|  2字节   |   0x0008   | 压缩方法（0x0008表示使用deflate 压缩） |
|  2字节   |   0x7b38   |          压缩文件最后修改时间          |
|  2字节   |   0x548b   |          压缩文件最后修改日期          |
|  4字节   | 0xf7d18982 |            文件的CRC32标识             |
|  4字节   | 0x00000007 |             文件压缩后大小             |
|  4字节   | 0x00000005 |             文件压缩前大小             |
|  2字节   |   0x0009   |               文件名长度               |
|  2字节   |   0x0000   |              扩展区的长度              |
|  2字节   |   0x0000   |              文件注释长度              |
|  2字节   |   0x0000   |         文件开始位置磁盘的序号         |
|  2字节   |   0x0001   |              文件内部属性              |
|  4字节   | 0x00000020 |              文件外部属性              |
|  4字节   | 0x00000000 |          本地文件头的相对位移          |

##### 核心目录结束（End of central directory record）

Zip 格式的第三部分标识用于标记压缩的目录数据的结束，每个压缩文件必须有且只有一个核心目录结束记录。

的起始由 `0x06054b50`标识，字段内容以及含义由下表所示

| 字段大小 |  字段内容  |                字段含义                |
| :------: | :--------: | :------------------------------------: |
|  4字节   | 0x06054b50 |        核心目录结束字段起始标识        |
|  2字节   |   0x0000   |              当前磁盘编号              |
|  2字节   |   0x0000   |          核心目录起始磁盘编号          |
|  2字节   |   0x0001   |         磁盘记录的核心目录数量         |
|  2字节   |   0x0001   |           核心目录结构的总数           |
|  4字节   | 0x00000037 |             核心目录的大小             |
|  4字节   | 0x0000002e | 核心目录起始位置相对磁盘起始位置的位移 |
|  2字节   |   0x0000   |              文件注释长度              |

#### 时间日期编码

对于文件最后一次修改的时间以及日期的编码转换，可以通过使用`fstream`库当中对文件最后一次修改时间的获取方法

```cpp
_NODISCARD inline file_time_type last_write_time(const path& _Path)
```

传入文件的路径作为参数调用，函数将会返回一个含有时间信息的宏，通过返回的宏计算文件最后一次修改时间与系统起始时间的差值，最终通过该差值得到一个含有完整时间日期信息的结构体 `tm* whole_time`

```cpp
struct tm
{
    int tm_sec;   // seconds after the minute - [0, 60] including leap second
    int tm_min;   // minutes after the hour - [0, 59]
    int tm_hour;  // hours since midnight - [0, 23]
    int tm_mday;  // day of the month - [1, 31]
    int tm_mon;   // months since January - [0, 11]
    int tm_year;  // years since 1900
    int tm_wday;  // days since Sunday - [0, 6]
    int tm_yday;  // days since January 1 - [0, 365]
    int tm_isdst; // daylight savings time flag
};
```

首先是文件时间的转换，由于在 zip 相应字段当中只有两个字节来表示时间信息，其中小时以及分钟都是比较重要的信息，需要完全保留，所以使用5比特来编码小时，使用6比特来编码分钟，这样一来，表示60秒只有剩下的5比特了，所以精度不能精确到每一秒，这也可以看做是不重要项向重要项的在计算机科学当中的让步。这个设计也确实是妙，如果一定要将秒的精度精确到每一秒，则总共需要2个比特来编码时间信息，同时为了字节对齐以及后续数据的整齐，又需要额外的1个比特来进行字节对齐，这样压缩一个文件就需要额外花费一个字节，这样对于一个文件来说是不必要的，因为2秒的精确度在实际应用当中已经足够了，所以最终编码秒数的时候只能对秒数除以2进行保存。

在表示时间的字段当中最高的5比特位保存小时，次高的6比特位保存分钟，最低5位保存秒。通过以下的位运算可以实现时间的编码。

```cpp
		//File last modification time
        size_t s = whole_time->tm_sec / 2;
        size_t m = whole_time->tm_min;
        size_t h = whole_time->tm_hour;
        h <<= 6; // 将小时放到最高位，并左移6位来存放分钟
        h |= m;
        h <<= 5; // 左移5位来存放秒数信息
        h |= s;
```

对于文件最后修改日期的编码

#### 压缩大小计算

### 文件I/O操作

### deflate 算法

### LZ77 算法

### 静态哈夫曼编码

### 动态哈夫曼编码

### 比特发射器

### Cmake 整合代码

## Part3 Code

## Part4 Experiments and Improvements

### 代码正确性检验

### 压缩率与文本内容关系

### 压缩率与文本大小关系

### 压缩所需时间与文本大小关系

### I/O时间与压缩时间比率与文本大小关系

### 代码改进

## Part5 Difficultis and Solutions

### 字节对齐问题及解决

### CRC校验错误问题及解决

## Part 6 Summary

## Part 7 Reference

- ZIP 编码格式文档 	https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT

- 
